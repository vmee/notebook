# shell

终端：附着在终端的接口程序
- GUI： KDE,GHome,xfce
- CLI: /etc/shells
  - bash
  - zsh
  - fish

bash的特性
- 命令行展开：～，{}
- 命令别名：alias unalias
- 命令历史：history
- 文件名通配： glob
- 快捷键ctrl+a, e, u, k, l
- 命令补全：$PATH，各shell内部命令
- 路径补全：

bash特性之一： 命令hash
缓存之前执行的命令结果
执行命令先查找hash的命令结果，如果找不到再去hash下查找
- key 搜索键
- value 值

hash命令
- hash 列出
- hash -d COMMAND 删除
- hash -r 清空
  
bash特性之一：变量


## 编程语言的分类
根据运行方式
编译运行：源代码->编译器-->程序文件
解释运行：源代码->运行时启动解释器，由解释器边解释边运行

根据编程过程中功能的实现是调用库还是调用外部的程序文件
shell脚本编译：利用系统上的命令及编程组件进行编程
完整编程：利用库或编程缓件进行编程

编程模型：过程式编程语言，面向对象的编程语言
程序=指令+数据
过程式：以指令为中心来组织代码，数据服务于代码
- 顺序执行
- 选择执行
- 循环执行
代表：C,bash
对象式：以数据为中心来组织代码，围绕数据来组织指令
- 类class 实例化对象
- method 方法
代表：java,C++,python

shell脚本编程：过程式编程，解释运行，依赖于外部程序文件运行

## 如何写shell脚本
脚本文件的第一行，顶格，给出shebang,解释路径，用于指明解释执行当前脚本的解释器程序文件
常见的解释器
- #!/bin/bash
- #!/usr/bin/python
- #!/usr/bin/perl

文本编程器:nano
行编辑器：sed
全屏幕编程器：nano vi vim

shell脚本是什么？
命令的堆积，但很多命令不具有幂等性，需要用程序逻辑来判断运行是是否满足，以避免发生逻辑错误

## 运行脚本
- 赋予执行权限，并直接运行此程序文件
  - chmod +x file
  - /path/to/file
- 直接运行解释器，将脚本以命令行参数传递给解释器程序
  - bash /path/script_file

> 脚本中的空白行会被解释器忽略
> 脚本除了shebang,余下的所有#开头的行，都会被视作注释而被忽略，即注释行

## 文本处理工具
Linux文本处理三剑客
- grep 文本过滤工具（模式：pattern）工具
  - grep 基本正则表达式
  - egreg 扩展正式表达式
  - fgreg 
- sed stream editor 流编辑器，文本编辑工具
- awk Linux上实现的为gawk 文本报告生成器（格式化文本）


## 正则表达式 Regual Expression REGEXP
由一一类特殊字符及文本字符所编写的模式，其中有些字符不表示其字面意义 ，而是用于表示控制或通配的功能
分两类
- 基本正则表达式 BRE
- 扩展正则表达式 ERE

元字符：

## grep 
Grobal search regular expression and print out the line
作用：文本搜索工具，根据用户指定的“模式（过滤条件）” 对目标文本逐行进行匹配检查，打印匹配到的行
模式：由正则表达式的元字符及文本字符所编写出的过滤条件

正则表达式引擎：
- perl pcre

格式：grep [option] pattern [file..]

options
- --color=auth 对匹配到的文本着色后高亮显示 
- -i igonrecase 忽略字符的大小写 
- -o 仅显示匹配的字符串本身
- -v --invert-match 显示不能被匹配的行
- -E --extend-regexp 支持扩展的正则表达式
- -q --quiet 静默，不显示执行结果
- -A # after 显示后面行
- -B # before 显示前面行
- -c # context 显示前后的行


基本正则表达式：

贪婪模式

字符匹配
- . 匹配任意单个字符
- [] 匹配指定范围内的任意单个字符
- [^] 匹配指定范围外的任意单个字符
匹配次数
- * 匹配其前面字符的任意次 0，1多次
- .* 任意长度的任意字符
- \? : 匹配前面字符0次/1次，即其前面的字符是可有可无的
- \+ 匹配其前面的字符1次或多次; 即其前面的字符要出现至少一次
- \{m} 匹配其前面的字符m次
- \{m,n\} 匹配前面的字符至少m次，至少n次
  - \{0,n\}至多n次
  - \{m,\}至少m次


位置锚定
- ^: 行首锚定 用于模式的最左侧
- $：行尾锚定 用于模式的最右侧
- ^PATTERN$ 用于PATTERN来匹配整行
  - ^$ 空白行
  - ^[[:space:]]*$ 空行或包含空白字符的行


单词：非特殊字符组成的连续字符（字符串）都称为单词
- \<或\b 词首锚定 用于单词模式的左侧
- \>或\b 词尾锚定 用于单词模式的右侧
- \<PATTERN\> 匹配完整单词


分组及引用 
- \(\) 将一个或多个字符捆绑在一起，当作一个整体进行处理
  - \(xy\)*ab

> Note: 分组括号中的模式匹配到的内容会被正则表达式引擎自动记录于内部的变量中， 这些变量为：
> \1: 模式从左侧起，第一个左括号以及与之匹配的右括号之间的模式 所匹配到的字符
> \2: 模式从左侧起，第二个左括号以及与之匹配的右括号之间的模式 所匹配到的字符
> eg: grep "\(l..e\).*\1"

## egrep

支持扩展正则表达式 实现类似于grep文本过滤功能  grep -E

格式：egrep [option] pattern [file..]
options
- --color=auth 对匹配到的文本着色后高亮显示 
- -i igonrecase 忽略字符的大小写 
- -o 仅显示匹配的字符串本身
- -v --invert-match 显示不能被匹配的行
- -E --extend-regexp 支持扩展的正则表达式
- -q --quiet 静默，不显示执行结果
- -A # after 显示后面行
- -B # before 显示前面行
- -c # context 显示前后的行

扩展正则表达式的元字符：
字符匹配
- .: 任意单个字符
- []：指定范围内的字符
- [^]: 指定范围外的任意单个字符
次数匹配
- * 任意单个字符
- ？ 0次数或1次 其前面的字符可有可元
- + 其前字符至少1次
- {m} 其前的字符m次
- {m, n} 至少m次 至多n次
位置猫定
- ^: 行首锚定
- $：行尾锚定
- \<或\b 词首锚定
- \>或\b 词尾锚定
分组及引用
- ()分组： 括号内的模式匹配到的字符会被记录于正则表达式引擎的内部变量中
- 后向引用：\1,\2
或
- a|b : a或者b



